// other dependencies

// mustRunAfter
// - if two tasks execute one must run after the other

// shouldRunAfter
// - if wo tasks execute one shoud run after the other
// - This igrnores circular dependencies

// finalizedBy (incubating in 2.6)
// - inverted dependency

task TaskA { description = "task A" }
task TaskB { description = "task B" }
task TaskC { description = "task C" }
task TaskD { description = "task D" }
task TaskE { description = "task E" }


TaskA.dependsOn TaskB
TaskA.dependsOn TaskD, TaskC
// gradle has its on way to run through things
// changing the layout of the depends on statement
// does not affect the way they are handled by gradle
// order is undefined

// use the -q flag to just see your output
// -q for quiet

TaskC.dependsOn TaskE
TaskD.dependsOn TaskE


TaskA.dependsOn TaskE


// you can declared dependsOn within the closure 
task TaskG{
	dependsOn TaskE
	doLast{
		println "task G"
	}
}

TaskA.dependsOn TaskG

// lets say we want to run B after C and D
// notice how we can comma separate the tasks here
TaskB.mustRunAfter TaskC // , TaskD

TaskB.shouldRunAfter TaskD

task Task1 { println "task1" }
task Task2 { println "task2" }

 
Task2.mustRunAfter Task1
